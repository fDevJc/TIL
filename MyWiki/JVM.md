# JVM

### JVM 이란?
- Java Virtual Machine 의 약자로 OS위에서 자바프로그램을 실행하는 머신입니다.
- 자바는 컴파일러를 통해 .class 파일로 변환되는데 해당 파일은 기계어가 아닌 JVM을 위한 자바 바이트 코드로 구성되어있습니다.
- JVM은 class 파일을 로드하고 실행해주는 역할을 합니다.
- 자바는 이러한 JVM으로 인해 OS에 의존적이지 않은 언어가 될 수 있습니다.

### JVM 구조
JVM의 구조는 크게 클래스로더, 런타임 데이터 에어리어, 실행엔진 세 가지로 구성되어있습니다.
- 클래스로더
    - 클래스 로더는 클래스파일을 로딩하여 자바파일이 실행될 수 있도록 준비하는 역할을 합니다.
    - 클래스 로더는 3가지 과정을 거치게 됩니다.
        - 로딩
            - 클래스 파일을 로드하는 과정입니다.
            - JVM에는 3가지의 클래스로더를 거쳐 클래스 파일을 로드하게 됩니다.
                - BootStrapClassLoader
                    - 클래스로더의 최상위 계층 로더입니다.
                    - Java 핵심라이브러리를 로드하는 역할을 수행합니다.
                - ExtentionClassLoader
                    - java 라이브러리의 ext 디렉토리 혹은 java.ext.dirs 환경변수에 선언되어있는 라이브러리를 로드합니다.
                - ApplicationClassLoader
                    - 실제 개발자가 개발한 자바파일을 로드 합니다.
            - 3가지의 클래스로더를 거치게 되고 클래스파일을 찾지못하면 ClassNotFoundException이 발생하게 됩니다.
        - 링크
            - 클래스 파일을 검증하고 초기값으로 초기화하는 과정입니다.
            - 링크 역시 3가지 과정을 거치게 됩니다.
            - 검증
                - 클래스파일이 유효한지 검증된 컴파일러를 통하여 컴파일되었는지 등 클래스파일을 검증합니다.
                - 검증에 실패할 경우 VerifyError가 발생합니다.
            - 준비
                - 클래스 변수등을 메모리에 할당하고 초기값으로 초기화하는 과정을 거칩니다.
            - 해결
                - 심볼릭 레퍼런스를 실제 메모리 레퍼런스로 변환하는 과정을 거칩니다.
        - 초기화
            - 클래스와 인터페이스의 값들을 지정한 값으로 초기화 및 초기화 메서드를 실행합니다.
- 런타임 데이터 에어리어
    - PC Register
        - 쓰레드 마다 생성되며, 쓰레드의 현재 실행 주소 등의 정보를 저장하는 곳입니다.
    - JVM Stack
        - 쓰레드 마다 생성됩니다.
        - 메소드를 실행하면 Frame이라는 데이터를 추가(push)하게 되고 메소드 실행이 종료되면 삭제(pop)하게 됩니다.
        - Frame에는 로컬변수 등의 정보를 가지고 있으며, 기본 타입의 경우 값자체가 담겨있고, 참조 타입의 경우 Heap의 메모리주소를 가지고 있습니다.
    - Navtive Method Stack
        - 자바 외의 언어를 위한 저장 공간입니다.
    - Heap
        - new 연산이나 배열등 객체들을 저장하는 공간입니다.
        - JVM에 하나의 Heap이 생성됩니다.
    - Method Area
        - 클래스, 인터페이스, 메소드등 메타데이터를 저장하는 공간입니다.
        - Runtime Constant Pool 스태틱 영역에 존재하는 별도의 저장공간입니다.
- 실행엔진
    - 바이트 코드를 기계어로 변경하여 명령어 단위로 실행
    - 인터프리터
        - 자바 바이트 코드를 명령어 단위로 하나씩 실행합니다.
        - 한줄씩 읽기때문에 속도가 느린편입니다.
        - 초기 자바의 경우 JIT컴파일러없이 인터프리터만으로 동작했습니다.
    - JIT 컴파일러
        - 인터프리터의 느린 속도를 보완하기위해 나오게되었습니다.
        - 같은 함수가 여러번 실행될 경우 해당 함수를 캐싱하여 속도를 향상시킵니다.
        - 한번만 실행되는 코드의 경우 JIT컴파일러로 컴파일하는 것보다 인터프리팅하는것이 빠른 속도를 보입니다.
        - JIT컴파일러에는 C1(클라이언트 컴파일러), C2(서버 컴파일러)로 나뉘어있습니다.
    - 가비지 컬렉터
        - 객체의 참조가 끊어졋을때 해당 객체를 메모리에서 삭제해주는 역할을 수행합니다.
        - 자바의 메모리의 경우 
            - Heap Memory
                - Eden
                    - 새로운 객체가 생성되었을때 저장되는 공간입니다.
                    - 해당 영역이 가득찰경우 minorGC가 발생합니다.
                - Survivor0,1
                    - MinorGC가 발생할경우 살아남은 객체들이 저장되는공간입니다.
                    - From,To 혹은 0,1 로 2개의 공간이 있으며 MinorGC가 일어날때마다 0->1혹은, 1->0으로 이동하며 두개의 공간에 동시에 저장되지는 않습니다.
                - Old
                    - MinorGC가 실행되고 서바이버공간에서 이동하게 되면 age값이 플러스가 되게 되는데 특정 age이상의 객체들은 Old공간에 저장되게됩니다.
                    - Old영역이 가득 차게 되면 MajorGC가 발생합니다.
                    - MajorGC는 MinorGC보다 속도가 느리기에 자주발생하지 않도록 관리를 해줘야합니다.
                - PermGen(Java7이하)
            - Native Memory
                - metaspace(Java8이상)
        - GC 프로세스
            1. 새로운 객체는 Eden 영역에 저장되며, 두개의 Survivor공간은 비어 있습니다.
            2. Eden 영역이 가득차면 MinorGC가 발생합니다.
            3. MinorGC가 발생하면 Eden공간에서 참조가 끊어진(Unreachable) 객체들은 삭제되며 살아남은 객체들은 S0으로 이동됩니다.
            4. 다시 MinorGC가 발생하면 살아남은 객체들은 S1으로 이동되며 S0과 Eden은 비워지게 됩니다.
            5. 3~4번이 반복되며 age 값이 특정값이상이 되면 Old Generation으로 이동되며 이 단계를 Promotion이라 합니다.
            6. MinorGC가 지속적으로 발생하며 이때 Promotion도 함께 지속적으로 발생합니다.
            7. Old Generation이 가득차게 되면 MajorGC가 실행됩니다.
            
        - MajorGC의 종류
            - SerialGC
            - Parallel GC
            - Parallel Old GC
            - CMS GC
            - G1 GC