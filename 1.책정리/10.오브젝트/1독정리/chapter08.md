## Chapter08 의존성 관리하기
- 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성
    - 초점이 명확하고 한가지 일을 잘하는 객체
- 객체들이 서로 도움을 요청하고 협력하며 애플리케이션 기능 구현
- 협력은 객체가 다른 객체에 대해 알 것을 강요, 존재 사실도 알아야한다, 수신할 수 있는 메시지도 알아야한다. 이는 객체 사이의 의존성을 낳는다.
- 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 변경을 힘들게 만든다.
- 필요한 의존성을 유지하며 변경을 방해하는 의존성을 제거해야한다
- 의존성은 구현시점과 실행시점에 다른 의미를 가진다
- 두 객체 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 변경될 수 있다는 것을 의미
- 의존성은 전이 될 수 있다
- 의존성의 종류
    - 직접 의존성
    - 간접 의존성
- 의존성이란 의존하고 있는 대상의 `변경`에 영향을 받을 수 있는 가능성
- 런타임 의존성
    - 주인공은 객체
- 컴파일 의존성
    - 주인공은 클래스
- 유연하고 재사용 가능한 설계를 위해서는 런타임 의존성과 컴파일 의존성을 다르게
- 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스화 협력하기 위해서는 협력할 인스턴스의 구체적인 정보를 알면 안된다. 이를 `런타임`에 해결
- 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합
- 컨텍스트 독립성
    - 설계가 유연해지기 위해서는 자신이 실행될 컨텍스트에 구체적 정보를 최대한 적게
- 의존성 해결 (런타임시 의존성을 교체)
    - 생성자
    - 세터
    - 메서드 인자
- 결합도
    - 서로에 대해 알고 있는 지식의 양이 결합도를 결정
- 추상화에 의존
    - 구체 클래스 의존
    - 추상 클래스 의존
    - 인터페이스 의존
    - 아래로 갈수록 결합도가 느슨
- 설계는 트레이드 오프
    - 사용성을 생각해 내부에서 구체적인 객체에 의존하는 경우도 있다
    - 생성자를 체이닝


---

## 정리
- 구체적인것 말고 추상화에 의존하라
- 설계는 트레이드 오프의 연속이다!!
- 279p OverlappedDiscountPolicy는 생각못했네,,,굿