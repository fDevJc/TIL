## Chapter13 서브클래싱과 서프타이핑
- 상속
    - 타입 계층을 구현하는 것
        - 부모클래스는 일반적인 개념을 구현, 자식클래스의 `일반화`
        - 자식클래스는 특수한 개념을 구현, 부모클래스의 `특수화`
    - 코드 재사용
        - 코드 재사용을 위한 상속은 부모클래스와 자식클래스가 강하게 결합
- 타입 계층을 목표로 상속을 사용한다면 다형적으로 동작하는 확장가능하고 유연한 설계를 얻을 수 있다
- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성
- 상속은 서브타입 다형성과 동적 메서드 탐색에 밀접하게 연관
- 객체기반 프로그래밍과 객체지향 프로그래밍
    - 상태와 행동을 캡슐화한 객체를 이용한다는 점에서 공통점
    - 하지만 객체 지향 프로그래밍의 경우 상속과 다형성을 지원
    - 객체기반 프로그래밍은 객체지향 프로그래밍을 포함
- 개념 관점의 타입
    - 인지하는 세상의 사물의 종류
    - 우리가 인식하여 객체들에 적용하는 개념이나 아이디어 등을 가리켜 타입
    - 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 한다
    - 타입의 인스턴스를 객체
- 타입
    - 심볼
        - 타입에 이름
        - ex) 프로그래밍 언어
    - 내연
        - 타입의 정의
        - ex) 컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법의 규칙의 집합
    - 외연
        - 타입에 속하는 객체들의 집합
        - ex) 자바,루비,자바스크립트 등
- 프로그래밍 언어 관점의 타입
    - 연속적인 비트에 의미와 제약을 부여하기 위해 사용
    - 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 애플리케이션에 달림
    - 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다
    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스의 집합
- 객체지향 패러다임 관점의 타입
    - 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의 하는 것
    - 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일
    - 객체 지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다
    - 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류
    - 객체에게 중요한건 속성이 아니라 행동!
    - 어떤 객체들이 동일한 속성을 가지더라도 행동이 다르면 다른 타입, 내부 속성은 다르지만 동일한 퍼블릭 인터페이스를 가진다면 동일한 타입
    - 객체를 바라볼때는 항상 외부에 제공하는 객체의 행동에 중심.
    - 객체의 타입을 결정하는 것은 객체내부의 속성이아니라 외부에 제공하는 행동!!
- 타입 계층
    - 타입은 다른 타입을 포함하는 것이 가능
    - 타입이 다른 타입에 포함될 수 있기 때문에 하나의 객체가 여러 타입에 포함되어 질 수 있다
    - 다른 타입을 포함하는 타입은 좀더 일반화된 의미를 표현
        - 외연관점에서는 좀더 크고 내연관점에서는 좀더 일반적
    - 슈퍼타입, 서브타입이라고도 부름
        - 슈퍼타입
            - 집합이 서브 집합의 모든 멤버를 포함
            - 타입 정의가 서브 타입보다 일반적
            - 서브타입에 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의
        - 서브타입
            - 더 큰 집합에 포함된다
            - 구체적
            - 슈퍼타입에 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의
    - 내연 관점에서 일반화와 특수화란
        - 일반화: 좀더 보편적, 추상적으로 만드는 과정
        - 특수화: 좀더 구체적, 문맥에 종속적으로 만드는 과정
    - 특수한 타입(서브타입)에 속한 인스턴스는 일반적인 타입(슈퍼타입)의 인스턴스이기도 하다
- 객체의 타입을 결정하는 것은 퍼블릭 인터페이스
- 객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용, 타입계층을 구현하는 일반적인 방법은 상속
- 클라이언트 관점에서 두 클래스에 대해 기대하는 행동이 다르다면 어휘적으로 is-a 관계이더라도 상속을 사용하면 안된다
    - 어휘적인 정의가 아니라 행동에 따라 타입 계층을 구성해야한다
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다,
    - ex) 펭귄은 새다
    - 펭귄은 날지 못한다, 클라이언트 관점에서 날수있다라는 행동을 기대하지않고 울음소리를 낸다라는 행동에 대한 기대만 존재한다면 타입 계층으로 묶어도 적합하지만, 클라이언트 관점에서 날수있다는 행동을 기대한다면 같은 계층으로 묶는것은 적합하지 않다
- 행동호환성
    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식클래스의 차이점을 몰라야한다
    - 타입은 행동과 관련
    - 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야한다
    - 행동의 호환여부를 판단하는 기준은 클라이언트 관점
    - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입은 타입계층으로 묶을 수 있다
    - 서브타입이 되기 위해서는 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야한다
    - 서브타입과 슈퍼타입의 행동 호환성은 슈퍼타입에 대한 서브타입의 대체가능성을 포함
- 클라이언트의 기대에 따라 계층 분리하기
    - ex) interface Flyable, interface Walkable
    - class 펭귄, class 새
    - 날수있는 행동을 기대하는 클라이언트는 Flyable에 의존
    - 위처럼 클라이언트 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(ISP)라 한다
    - 중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동
- 서브클래싱
    - 코드의 재사용 목적으로 상속을 사용하는 경우
    - 구현상속, 클래스 상속
- 서브타이핑
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 인터페이스 상속
- 리스코프 치환 원칙
    - LSP
    - 서브타입은 슈퍼타입에 대해 대체 가능해야한다
    - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야한다
    - 리스코프 치환 원칙은 행동 호환성을 설계 원칙을 정리
    - 상속 관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하지마라
    - 상속 관계는 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을때만 올바르다
---

## 정리
- 책을 읽을 수록 그냥 생각없이 이해? 외웠던? 객체지향의 5대원칙 SOLID에 대해 다시 한번 생각해보게 되는거 같다