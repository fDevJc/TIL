# 대규모 데이터 처리 입문
- 디스크는 왜 늦을까?
    - 메모리는 전기적인 부품
    - 디스크는 물리적인 동작을 수반
    - 디스크에서는 헤드의 이동과 원반의 회전이라는 두 가지 물리적인 이동이 필요
- OS는 연속된 데이터를 디스크의 같은 위치에 쌓는다
    - 비슷한 데이터를 비슷한 곳에 두어 1번의 디스크 회전으로 읽는 데이터 수를 많게 한다
- 전송속도, 버스의 속도차
    - 탐색속도 측면뿐만 아니라 전송속도에서도 디스크와 메모리는 차이가난다
    - 메모리와 디스크는 모두 CPU와 버스로 연결
    - 메모리와 CPU는 상당히 빠른 버스로 연결, 디스크와 CPU는 상대적으로 느린 버스로 연결
    - 최근 SSD의 경우 탐색속도는 빠르지만, 버스 속도가 병목되는 경우가 있음
- 추측하지 마라, 계측하라
    - 계측함으로써 시스템의 병목을 규명하고, 이를 집중적으로 제거함으로써 성능을 향상
- 병목 규명작업의 기본적인 흐름
    - Load Average 확인
        - top이나 uptime등의 명령으로 load average를 확인
        - 시스템 전체의 부하상황을 나타내는 지표
        - 병목의 원인이 어디인지는 판단 불가
        - 값이 낮은데 시스템의 전송량이 오르지 않을 경우 네트워크, 설정 오류 등을 확인
    - CPU, I/O 중 병목 원인 조사
        - sar이나 vmstat로 시간 경과에 따라 CPU 사용률이나 I/O 대기율 추이 확인
        - CPU 부하가 높을 경우
            - 사용자 프로그램의 처리가 병목인지, 시스템 프로그램이 원인인지 확인. top, sar로 확인
            - ps로 볼 수 있는 프로세스 상태나 CPU 사용시간 등을 보면서 원ㅇ니이 되고 있는 프로세스 확인
            - 프로세스를 찾은 후 보다 상세하게 조사할 경우는 strace로 추적하거나 oprofile로 프로파일링해서 병목지점 좁힘
            - 일반적으로 CPU 부하가 걸리는 상황
                - 디스크나 메모리 용량 등 그 밖의 부분에서는 병목이 되지 않는, 말하자면 이상적인 상태
                    - 서버의 증설이나 프로그램 로직, 알고리즘을 개선
                - 프로그램이 폭주해서 CPU에 필요이상의 부하가 걸리는 경우
                    - 오류를 제거해서 프로그램이 폭주하지 않도록
        - I/O 부하가 높은 경우
            - 프로그램으로부터 입출력이 많아서 부하가 높거나 스왑이 발생해서 디스크 액세스가 발생하고 있는 상황 중 하나일 경우가 대부분
            - sar이나 vmstat로 스왑의 발생상황을 확인해서 문제를 가려냄
                - 특정 프로세스가 극단적으로 메모리를 소비하고 있지 않은지 ps로 확인할 수 있다
                - 프로그램의 오류로 메모리를 지나치게 사용하고 있는 경우에는 프로그램을 개선한다
                - 탑재된 메모리가 부족한 경우에는 메모리를 증설한다. 메모리를 증설할 수 없을 경우는 분산을 검토한다
            - 스왑이 발생하지 않고 디스크로의 입출력이 빈번하게 발생하고 있는 상황은 캐시에 필요한 메모리가 부족한 경우를 생각해볼 수 있다.
                - 메모리 증설로 캐시영역을 확대시킬 수 있는 경우는 메모리를 증설
                - 메모리 증설로 대응할 수 없는 경우는 데이터 분산이나 캐시서버 도입 등을 검토
- OS 튜닝이란 부하의 원인을 알고 이것을 제거하는 것
    - 애초에 본래 하드웨어나 소프트웨어가 지니고 있는 성능 이상의 성능을 내는 것은 불가능
    - 하드웨어, 소프트웨어가 본래 지닌 성능을 충분히 발휘할 수 있도록 문제가 될 만한 부분이 있으면 제거
- I/O성능을 개선하기 위해서
    - 메모리를 증설해서 캐시 영역을 확보함으로서 대응할 수 있는가
    - 원래 데이터량이 너무 많지는 않은가
    - 애플리케이션 측의 I/O 알고리즘을 변경할 필요가 있는가
- 웹 애플리케이션과 부하의 관계
    - I/O작업의 경우 스케일아웃에서 동기화 문제를 생각해야한다
- CPU 부하의 스케일 아웃은 비교적 간단
    - 같은 구성의 서버를 늘리고 로드밸런싱
- I/O 부하의 경우 스케일 아웃은 비교적 어렵다
- top의 출력내용의 load average
    - 0.70, 0.66, 0.59
    - 왼쪽부터 1분, 5분, 15분 동안에 단위시간당 대기된 태스크의 수
    - load average가 의미하는 부하
        - 처리를 실행하려고 해도 실행할 수 없어서 대기하고 있는 프로세스의 수
        - CPU의 실행권한이 부여되기를 기다리고 있는 프로세스
        - 디스크 I/O가 완료하기를 기다리고 있는 프로세스
- 대규모 시스템을 고민하게 만드는 대규모 데이터, 이것을 다루는 요령
    - 어떻게 하면 메모리에서 처리를 마칠 수 있을까
        - 디스크 seek 횟수 최소화
    - 데이터량 증가에 강한 알고리즘을 사용하는 것
    - 데이터 압축이나 검색기술과 같은 테크닉 활용
- sar
    - 시간경과에 따라 비교 열람 가능
    - %user는 사용자 모드에서 CPU 사용률
    - %system은 시스템 모드에서의 CPU 사용률
    - %iowait는 I/O 대기율