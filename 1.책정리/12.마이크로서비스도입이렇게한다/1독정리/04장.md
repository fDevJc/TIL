## 데이터베이스 분해
- 데이터베이스 분리하는 작업은 데이터 동기화 문제, 논리적 스키마와 물리적 스키마의 분해, 트랜잭션 무결성, 조인, 대기 시간 등을 고려해야 한다

### 패턴: 공유 데이터베이스
- 여러 마이크로서비스가 하나의 공유데이터베이스를 사용하는 패턴
- 결합도가 높다
- 정보은닉이 안됨
- 뷰를 사용해 완화될 수 있으나 완벽한 해법은 아니다
- 적용대상
    - 읽기 전용 정적 참조 데이터를 고려할 경우(국가 통화코드,우편번호 등)
    - 서비스가 여러 컨슈머를 다루기 위해 설계되고 관리되는 종단점으로서 데아터베이스를 직접 외부에 공개하는 경우
        - 데이터베이스 인터페이스 패턴
- 비추

### 패턴: 데이터베이스 뷰
- 제한적으로 스키마를 서비스에 제공
    - 정보 은닉을 할 수 있다

### 패턴: 데이터베이스 래핑 서비스
- 래퍼역할을 하는 서비스 뒤에 데이터베이스를 숨기고 데이터베이스 종속성에서 서비스 종속성으로 이동하게 만듬
- 데이터베이스의 부하가 늘어나지 않도록 방지하는 역할을 해줄 수 있다
- 추가되는 데이터의 경우 로컬에 저장하도록 권장하여 모놀리스 데이터베이스의 부하를 줄임

### 패턴: 서비스로서 데이터베이스(Daas) 인터페이스
- 마틴파울러는 리포팅 데이터베이스 패턴으로 명했음
- 때로는 클라이언트에서 쿼리를 위한 데이터베이스가 필요하다. 많은 양의 데이터를 쿼리해야할 경우
- 뷰를 제공하는거보다 유연함 (엔진이 다를 경우 등)

## 데이터 동기화
### 패턴: 애플리케이션에서 데이터 동기화
1. 데이터 대량 동기화
2. 이전 스키마에서 읽고 쓰기를 동기화
3. 새 스키마에서 읽고 쓰기를 동기화

### 패턴: 예광탄 기록

## 물리적 데이터베이스 분리 vs 논리적 데이터베이스 분리
- 논리적 분해는 독자적인 변경과 정보 은닉이 가능
- 물리적 분해는 잠재적으로 시스템 견고성을 개선하고 자원 경합을 제거하는 과정에 도움

# 데이터베이스를 먼저 분할? 코드를 먼저 분할?
- 저자는 성능이나 데이터 일관성 문제가 특히 우려되는 경우 데이터베이스를 먼저 분할하는 방식을 채택

# 트랜잭션
## ACID
- 원자성
    - Atomicity
    - 모든 연산 커밋, 롤백
- 일관성
    - Consistency
    - 데이터베이스가 변경되면 일관된 상태를 유지
- 격리성
    - Isolation
    - 다른 트랜잭션의 간섭없이 동작
- 내구성
    - Durability
    - 트랜잭션이 완료되면 데이터가 손실되지 않아야한다

## 2단계 커밋
- 투표단계와 커밋 단계로 나뉨
- 중앙 코디네이터가 워커에게 작업가능 여부를 확인하고 모든 워커들의 답을 들은 후 커밋요청 후 모든 워커는 커밋 작업 실행
- 작업 가능 여부를 확인하고 커밋명령을 받기전까지 레코드를 잠궈야 할것이다
- 여러 커밋이 동시에 일어나는지 확신할 수 없다(격리성 위반, 사가패턴도 격리성 위반)
- 워커가 많고 대기 시간이 길수록 문제가 발생

## 사가 패턴
- 오케스트레이션 패턴
    - 중앙코디네이터가 관리
    - 인프라 구현 난이도 상승
- 코레오그라피 패턴
    - 각 서비스가 트랜잭션을 완료하면 완료이벤트를 다음서비스에게 전송
    - 순차적으로 실행