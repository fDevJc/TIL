# 애그리거트
- 주요 도메인 개념 간의 관계를 파악하기 어렵다는 것은 곧 코드를 변경하고 확장하는 것이 어려워진다는 의미
- 애그리거트
    - 모델을 이해하는 데 도움
    - 일관성 관리 기준
    - 관련된 모델을 하나로 모은 것
    - 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다
    - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
    - 애그리거트는 독립된 객체군
    - 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다
    - 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항
    - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다
    - 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어든다
    - 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재
- 애그리거트 루트
    - 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이를 책임지는 것이 애그리거트의 루트 엔티티
    - 애그리거트의 루트엔티티의 핵심역할은 애그리거트의 일관성을 깨지지 않도록 하는 것
    - 애그리거트 루트는 애그리거트의 도메인 기능을 제공
    - 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현
    - 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
        - ex) 게터,세터가 외부에 공개되어있으면 애그리거트가 강제하는 규칙을 적용할 수 없다
        - 이는 `업무 규칙을 무시하고 DB 테이블에서 직접 데이터를 수정하는 것`과 같은 결과
    - 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만드려면
        - 단순히 필드를 변경하는 set 메서드를 공개 범위로 만들지 않는다
        - 밸류 타입은 불변으로 구현
- 트랜잭션 범위
    - 트랜잭션 범위는 작을수록 좋다
    - 한 트랜잭션에서는 한 개의 애그리거트만 수정
        - 애그리거트는 서로 최대한 독립적
        - 애그리거트가 다른 애그리거트의 기능에 의존하게되면 결합도가 높아진다
        - 한 트랜잭션에서 두개의 애그리거트를 수정해야할 경우 애그리거트 내에서 다른 애그리거트를 수정하는 것이아니라 응용 서비스에서 두 애그리거트를 수정
- 리포지터리와 애그리거트
    - 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
    - ORM 기술 중의 하나인 JPA/하이버네이트를 사용하면 데이터베이스 관계형 모델에 객체 도메인 모델을 맞춰야 하는 경우도 있다
        - 관계형 DB를 사용하거나 DB 설계 표준을 따라야 한다면 DB 테이블 구조에 맞게 모델을 변경해야 한다
        - 이경우 밸류 타입인 도메인 모델을 엔티티(JPA의 @Entity)를 이용해야 할수 있다
        - 🤔 도메인 모델의 엔티티와 JPA의 엔티티는 다르다
            - `관계형 DB를 사용할경우 테이블 구조에 맞게 도메인 모델이 변경될 수 있다`
- ID를 이용한 애그리거트 참조
    - 한 객체가 다른 객체를 참조하는 것처럼 애그리거트가 다른 애그리거트를 참조할 수 있다
        - 다른 애그리거트의 루트를 참조
    - 직접 참조할 경우 구현의 편리함
        - 단점
            - 편한 탐색 오용
                - 애그리거트에서 다른 애그리거트를 접근 할 수 있으면 애그리거트의 상태를 변경하기 쉽게 된다
                - 애그리거트가 관리하는 범위는 자기 자신으로 한정
                - 애그리거트 간의 결합도를 낮춰라
            - 성능에 대한 고민
                - 지연로딩, 즉시로딩 등
            - 확장 어려움
                - 부하를 분산하기 위해 하위 도메인별로 시스템을 분리할 경우 직접참조가 어려워짐
    - 위의 단점을 해소하기 위해 직접참조가 아닌 아이디를 이용한 간접참조
        - 아이디를 사용하면 모든 객체가 참조로 연결되지 않고 `한 애그리거트에 속한 객체들만 참조로 연결`
        - 애그리거트간의 의존을 제거 응집도를 높여줌
        - 아이디를 사용하면 복잡도를 낮추는 것과 함께 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지
        - 애그리거트별 다른 구현 기술 사용가능(다른 데이터베이스)
        - ID를 활용한 애그리거트 참조는 지연 로딩과 같은 효과를 만든다 -> N+1 문제
            - 아이디방식을 사용하며 N+1 조회와 같은 문제가 발생하지 않도록 하려면 전용 조회 쿼리를 사용
- 애그리거트 간 집합 연관
    - 개념적으로 1:N 연관이 있더라도 성능상의 문제 때문에 애그리거트간의 1:N 연관을 실제 구현에 반영하는 경우는 드물다
- 애그리거트를 팩토리로 사용하기
    - 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자
        - 🤔 이건 애그리거트간의 결합도를 높이는 거 아닌가..??
        - 도메인 서비스를 이용하는게 좋아보임

    
