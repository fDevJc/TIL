# 리포지터리와 모델구현(JPA중심)
- 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜 의존을 낮추는 것이 좋다
- 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성한다
- 루트 엔티티와 루트 엔티티에 속한 벨류는 한 테이블에 매핑될때가 많다
- 엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 게터 세터 메서드를 구현하지 말아야한다.
    - 세터의 경우 객체 내부의 상태를 임의로 변경할 수 있으므로 캡슐화가 깨진다
- 밸류타입이 컬렉션인 경우 별도 테이블로 매핑
- 밸류타입의 식별자
    - 장점은 식별자에 기능을 추가할 수 있다는 장점
        - ex) 주문번호가 1세대,2세대 다른 주문번호를 사용한다면 1,2세대를 구분해줄 수 있는 기능 추가
- `루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심`
    - 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인것은 아니다
    - 밸류가 아니라 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인
    - 특히 자신만의 독자적인 라이프사이클을 갖는다면 다른 애그리거트일 가능성이 높다
    - 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 여부를 확인하는 것
    - 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안된다
    - 별도 테이블로 저장되고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 고유 식별자를 갖는 것은 아니다
- 애그리거트 로딩 전략
    - JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 하나가 된다는 것
        - 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정
        - 즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함께 로딩할 수 있는 장점이 있지만, 이 장점이 항상 좋은 것은 아니다
            - 즉시로딩 방식으로 조회할경우 연관관계에 있는 엔티티를 조인해서 가져옴
            - 카타시안 조인을 사용하여 중복 발생
            - 적은 수의 경우 상관없지만 곱하기로 실행되기때문에 데이터가 조금만 많아지더라도 과한 데이터가 조회됨
        - 애그리거트는 개념적으로 하나여야 한다. 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다
            - 애그리거트가 완전해야하는 이유는
                - 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야된다.
                - 표현 영역에서 애그리거트의 상태를 보여줄 때 필요(조회용 기능을 구현하면 된다)
            - JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않음