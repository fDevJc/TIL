# 애그리거트 트랜잭션 관리
- 운영자와 고객이 동시에 한 주문 애그리거트를 수정하는 과정
    - 운영자 스레드와 고객 스레드는 `같은 주문 애그리거트를 나타내는 다른 객체를 조회`한다
        - 트랜잭션마다 리포지토리는 새로운 애그리거트 객체를 생성
    - 운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트이지만 물리적으로 서로 다른 애그리거트 객체를 사용
    - 운영자 스레드가 주문 객체의 배송상태를 변경하더라도 고객 스레드의 주문 객체에는 영향을 주지 않음
    - 애그리거트의 일관성이 깨지게 된다
    - 애그리거트의 일관성이 깨어지지 않기위해서는
        - 특정 스레드가 주문 애그리거트를 조회하고 변경하는 동안 다른 스레드에서 애그리거트를 수정하지 못하도록 막는다
        - 특정 스레드가 주문 애그리거트를 조회한 이후 다른 스레드에서 주문 애그리거트를 수정하였을 경우 조회했던 애그리거트를 다시 조회한 뒤 수정해야 한다

- 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는
    - Pessimistic 선점, 비관적 잠금
    - Optimisitic 비선점, 낙관적 잠금

- Pessimistic 선점, 비관적 잠금
    - 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식
    - 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소
    - 선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현
    - 다수 DBMS가 for update와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공
    - 선점 잠금과 교착 상태(dead lock)
        - 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의
        - 교착 상태가 발생하지 않도록 하기 위해서는 잠금을 구할 때 최대 대기 시간을 지정
            - JPA에서는 hint를 활용하여 최대 대기시간을 지정
            - DBMS가 교착상태에 빠진 커넥션을 처리하는 방법이 다르므로 확인 후 사용
- Optimisitic 비선점, 낙관적 잠금
    - 잠금을 해서 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DB에 반영하는 시점에 변경가능 여부를 확인
    - JPA는 @Version을 통해 지원
    - 버전이 동일한 경우에만 수정가능
    - 애그리거트내에 루트 엔티티 말고 다른 엔티티의 값이 변경되었을 경우 낙관적 잠금은?
        - 강제로 버전을 올려야한다
        - LockModeType.OPTIMISTIC_FORCE_INCREMENT를 사용하면 엔티티의 변경여부와 상관없이 버전을 상승

- 오프라인 선점 잠금
    - Named lock, user level lock
    - 애플리케이션 혹은 DB에서 락을 획득하는 방법