# 키-값 저장소 설계
- 키값 저장소는 키값 데이터베이스라고도 불리는 비 관계형 데이터베이스
- 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다
- 키는 일반 텍스트일수도 해시 값일 수 도 있다
- 값은 문자열일수도 리스트일 수도 객체일 수도 있다
- 단일 서버 키-값 저장소
    - 한 대 서버만 사용하는 키-값 저장소
    - 모든 데이터를 메모리 안에 두는 것이 불가능할 수 있다
        - 데이터 압축
        - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장(캐시)
- 분산 키-값 저장소
    - CAP 정리
        - Consistency 일관성
            - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다
        - Availability 가용성
            - 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다
        - Partition Tolerance 파티션 감내
            - 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 동작하여야 한다는 것을 뜻한다.
        - CAP 정리는 이들 가운데 어떤 두가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미
        - CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생
        - AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성을 희생
        - CA 시스템: 일관성과 가용성을 지원하는 키-값 저장소. 네트워크 장애는 피할 수 없으므로 실세계에 CA는 존재하지 않음
        - 실세계의 분산 시스템
            - n1, n2, n3 세 개의 노드가 존재한다고 가정할 때, n3의 문제로 파티션 문제 발생
                - 일관성과 가용성 사이에서 하나를 선택해야 한다
                - 가용성 대신 일관성을 선택한다면 (CP 시스템)
                    - 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 나머지 서버의 쓰기 작업을 중단해야 한다 그럴 경우 가용성이 깨진다
                    - 은행권 시스템
                - 일관성 대신 가용성을 선택한다면 (AP 시스템)
                    - 낡은 데이터를 반환하는 위험이 있더라도 계속 읽기 연산을 수행
                    - 파티션 문제가 해결된 뒤 새로운 데이터를 n3에 전송
        - 요구사항에 맞도록 CAP 정리를 적용
- 시스템 컴포넌트
    - 데이터 파티션
        - 대규모 애플리케이션의 경우 하나의 서버에 모든 데이터를 저장할 수 없기에 작은 파티션들로 분할한 다음 여러 서버에 저장
            - 데이터를 여러 서버에 고르게 분산할 수 있는가?
            - 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?
        - 안정 해시 알고리즘
            - 규모 확장 자동화
            - 다양성: 각 서버의 용량에 맞게 가상 노드의 수를 조정. 고성능 서버는 많은 노드 할당
    - 데이터 다중화
        - 높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다
    - 데이터 일관성
        - 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.
        - N = 사본 개수
        - W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다
        - R = 읽기 연산에 대한 정족수.
        - W = 1 이란 하나의 서버에 쓰기 연산을 한다는 것이 아닌 쓰기 연산이 성공했다고 판단하기 위해 코디네이터는 최소 한 대 서버로부터 성공 응답을 받아야 한다는 뜻이다.
        - R = 1, W = N: 빠른 읽기 연산에 최적화된 시스템
        - R = N, W = 1: 빠른 쓰기 연산에 최적화된 시스템
        - W + R > N: 강한 일관성이 보장됨
        - W + R <= N: 강한 일관성이 보장되지않음
    - 일관성 모델
        - 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환.클라이언트에 절대로 낡은 데이터를 전송하지 않는다
            - 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지
            - 고가용성 시스템에는 적합하지 않다
        - 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
        - 최종 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델
            - 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨저질 수 있다.
            - 해당 문제는 클라이언트가 해결
                - 데이터 버저닝
                    - 버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것
                        - n1 - s1: 이름 A를 Aa로 변경
                        - n2 - s2: 이름 A를 AA로 변경
                        - 두개의 버전 충돌
                        - 이를 해결해내기위해 버저닝 시스템이 필요
                        - 벡터 시계는 이런 문제를 푸는데 보편적으로 사용되는 기술
                    - 벡터 시계
                        - [서버, 버전]의 순서쌍을 데이터에 매단 것
                        - 선행 버전인지, 후행 버전인지, 다른 버전과 충돌이 있는지 판별
                        - D([s1, v1], [s2, v2]...) :D데이터, s서버, v버전
                        - 데이터 추가시 [si, vi]가 존재하면 vi를 증가
                        - 존재하지 않으면 새항목 [si, 1] 생성
                        - 위의 예를 들면
                            - A[sx, 1]
                            - Aa([sx, 1], [s1, 1])
                            - AA([sx, 1], [s2, 1])
    - 장애 처리
        - 장애 감지
            - 가십 프로토콜같은 분산형 장애 감지
        - 장애 처리
            - 일시적인 장애처리
            - 영구 장애처리
                - 해시 트리 비교
        
