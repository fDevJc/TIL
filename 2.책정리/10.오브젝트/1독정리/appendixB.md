## AppendixB 타입계층의 구현
- 많은 사람들이 갖고 있는 흔한 오해는 타입과 클래스가 동일한 개념이라는 것
- 타입은 개념의 분류를 의미
- 클래스는 타입을 구현하는 한 가지 방법
- 자바에서는 인터페이스와 클래스를 이용해 개별 타입을 구현한 후 이 두가지 종류의 타입 구현체를 함께 포함하도록 타입 계층을 구성할 수 있다
- 타입 계층을 구현하는 방법은 동일한 메시지에 대한 행동 호환성을 전제로 하기 때문에 다형성을 구현하는 방법이기도 하다
- 올바른 타입 계층이 되기 위해서는 서브타입이 슈퍼타입을 대체할 수 있도록 리스코프 치환 원칙을 준수해야 한다
- 리스코프 치환 원칙은 특정한 구현 방법에 의해 보장될 수 없기 때문에 클라이언트 관점에서 타입을 동일하게 다룰 수 있도록 의미적으로 행동 호환성을 보장하는 것은 개발자의 책임
- 타입은 객체의 퍼블릭 인터페이스를 가리키기 때문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것과 같다
- 타입을 구현할 수 있는 방법이 단 한 가지만 존재하는 경우에는 타입과 클래스를 동일하게 취급해도 무방
- 타입을 구현할 수 있는 다양한 방법이 존재하는 순간부터 클래스와 타입은 갈라진다
- 구체 클래스를 상속받는것은 되도록 피하고 추상클래스나 인터페이스를 상속받도록 한다
- 클래스를 사용하지 않고도 타입을 구현할 수 있는 방법은 자바의 인터페이스를 사용하는 방법
- 여러 클래스가 동일한 타입을 구현할 수 있다
    - ex) Displayable을 구현한 Player, Displayable을 구현한 Monster
- 하나의 클래스가 여러 타입을 구현할 수 있다
    - ex) Displayable과 Effect를 구현한 Explosion
- 인터페이스를 이용해 타입을 정의하고 클래스를 이용해 객체를 구현하면 클래스 상속을 사용하지 않고 타입 계층을 구현할 수 있다
- 클래스와 타입간의 차이
    - 객체의 클래스는 객체의 구현을 정의
    - 클래스는 객체의 내부상태와 오퍼레이션 구현 방법을 정의
    - 타입은 인터페이스만을 정의하는 것으로 객체가 반응할 수 있는 오퍼레이션의 집합
    - 클래스도 객체가 만족할 수 있는 오퍼레이션을 정의하고 있으므로 타입을 정의하는 것이기도 하다
    - 객체 지향에서 중요한것은 협력안에서 객체가 제공하는 행동(퍼블릭인터페이스). 즉 클래스 자체가 아니라 타입이 중요하다
    - 타입이 식별된 후 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것이다
    - 클래스가 아니라 타입에 집중하라!, 중요한 것은 객체가 외부에 제공하는 행동!, 타입을 중심으로 객체들의 계층을 설계하는 것
- 추상 클래스
    - void 할인조건판단() {b()}
    - abstract void 할인조건계산(){}
    - a가 추상메서드 b를 의존하는 것도 의존성 역전 원칙의 변형
    - 할인조건판단을 구현한 추상클래스는 고차원모듈, 상속받아 할인조건계산을 오버라이딩한 서브클래스는 저차원 모듈
    - 고차원 모듈이 저차원 모듈의 구체적인 구현에 의존하는 것이 아닌 추상 메서드를 의존
- 골격 추상 클래스
    - 인터페이스와 추상 클래스 결합
    - 인터페이스에는 구현 코드를 넣을 수 없기때문에 중복코드가 발생, 이를 골격 추상 클래스로 완화
    - 자바8이상 부터는 인터페이스에 디폴트메서드를 지원
- 덕 타이핑
    - 객체가 어떤 인터페이스에 정의된 행동을 수행할 수만 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다
    - 메서드의 시그니처가 동일할경우 동일 타입으로 지원(루비는 지원)
    - 자바같은 정적 타입 언어에서는 코드상에 타입이 동일하게 선언되어있어야한다
- 객체지향 설계의 목표는 코드의 수정 비용을 줄이는 것
---
## 정리
- 음.. 이제 객체, 클래스, 타입, 인스턴스의 차이가 좀 더 느껴지는거같은 느낌적인 느낌
- 의존성 역전 원칙도 내가 이해하고 있던 것보다 다양한 의미가 있구나
- 다른 객체지향언어가 가지는 메커니즘?에 대해서도 배울 수 있게 되서 좋다. 이전에는 그냥 문법만 다르다고만 알고 있었다. 각언어가 추구하는 바가 존재하고 해당 개념, 기술 등을 각자 다른 방식으로 구현한것을 알게 되었다
- 변경! 변경! 결국 변경하기 쉬운 설계!
    - 변경을 위해 설계가 유연해야한다