## Chapter05 책임 할당하기
- 책임할당 과정은 일종의 트레이드오프 활동
- 책임 중심의 설계 원칙
    - 데이터보다 `행동`을 먼저 결정하라
    - `협력`이라는 문맥안에서 `책임`을 결정하라
- 객체에게 중요한건 외부로 제공하는 행동, 책임
- 객체의 데이터에서 행동으로 무게 중심을 옮기기 위해 객체를 설계하기 위한 질문의 순서를 바꾼다
    - 객체가 수행해야하는 책임은? -> 책임을 수행하는데 필요한 상태는?
- 책임은 객체의 입장이아니라 객체가 참여하는 `협력`에 적합해야 한다
- 즉 메시지 전송자에게 적합한 책임
- 메시지를 전송하는 클라이언트의 `의도`에 적합한 `책임`
- 메시지를 결정한 후 -> 객체를 선택
- 객체에게 `적절한 책임`을 할당하기 위해서는 `협력`이라는 문맥을 고려해야 한다.
- 협력이라는 문맥에서 `적절한 책임`은 `클라이언트의 관점에서 적절한 책임`을 의미한다
- GRASP 패턴
    - General Responsibility Assignment Software Pattern
    - 일반적인 책임 할당을 위한 소프트웨어 패턴
- Information Expert 패턴
    - 객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다는 일반적인 직관을 표현
    - 정보와 데이터는 다르다
    - 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없다
- 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도 측면에서 더 나은 대안을 선택
- 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다
- 코드를 통해 변경의 이유를 파악할 수 있는 방법
    - 인스턴스 변수가 초기화되는 시점을 살펴보는 것
        - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화
        - 응집도가 낮은 클래스는 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다
    - 메서드들이 인스턴스 변수를 사용하는 방식
        - 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다
        - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다
- 역할을 사용하면 객체의 `구체적인 타입을 추상화` 할 수 있다
- 역할을 대체할 클래스들 사이에서 `구현을 공유`해야 할 필요가 있다면 `추상 클래스`, 구현을 공유할 필요 없이 `역할을 대체하는 객체들의 책임만 정의`하고 싶다면 `인터페이스`
- 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당
- 변경을 캡슐화하도록 책임을 할당하는 것을 PROTECTED VARIATIONS(변경 보호) 패턴
- 캡슐화 해야하는 것은 변경이다. 변경 될 가능 성이 높다면 캡슐화 하라
- 도메인 모델은 구현과 밀접한 관계를 맺어야 한다

## 정리
- 객체의 책임은 협력이라는 문맥안에서 결정하라
- 객체의 책임은 클라이언트의 의도에 맞는 책임
- 객체의 책임(행동)을 결정하고 그에 맞는 상태를 고민하라
- 책임을 할당 할 수 있는 다양한 대안이 있다면 응집도와 결합도를 고려하라
- 변경될 가능성이 있다면 캡슐화 하라
- 리팩토링 하라