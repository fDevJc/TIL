## Chapter10 상속과 코드 재사용
- 클래스를 `재사용`하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법은 `상속`
- 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법
- 상속이외 방법 중에는 합성도 있다
- 코드를 재사용한다는 동기 이면에는 중복된 코드를 제거한다는 동기도 포함
- `중복 코드`는 `변경`을 방해한다
- 중복된 코드의 가장큰 문제는 코드를 수정하는 데 필요한 노력을 증가시킨다는 것
- 중복 여부를 판단하는 기준은 변경
- 요구사항이 변경되었을 때 두 코드를 함께 수정해야 한다면 코드는 중복, 함께 수정할 필요가 없다면 중복이 아니다
- 중복 코드를 판단하는 기준은 코드의 모양이 아니다
- DRY 원칙 (Don't Repeat Yourself)
- 중복 코드는 새로운 중복 코드를 부른다
- 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다
    - ex) public class Phone{ enum PhoneType {REGULAR, NIGHTLY}}
- 상속의 기본 아이디어는 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지말고 상속을 이용해 코드를 재사용해라는 것
- 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 쉽지 않다. 개발자는 재사용을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다. 그리고 그 과정은 코드를 이해하기 어렵게 만들고 직관에도 어긋날 수 있다
- 요구사항과 구현 사이의 차이가 크면 클수록 코드를 이해하기 어려워진다. 잘못된 상속은 이 차이를 더 크게 벌린다
- 결합도
    - 하나의 모듈이 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 정도
- 상속을 이용해 코드를 재사용하기 위해서는 `부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야한다`. 
이는 자식 클래스의 작성자가 `부모 클래스의 구현 방법에 대한 정확한 지식`을 가져야 한다는 것을 의미한다
- 즉 상속은 결합도를 높인다. 상속이 초래하는 부모 클래스와 자식 클래스의 강한 결합은 코드를 수정하기 어렵게 만든다
- 상속을 위한 경고
    - 자식 클래스의 메서드 안에서 super를 이용해 부모 클래스의 메서드를 직접 호출 할 경우 두 클래스는 강하게 결합. 
    super 호출을 제거할 수 있는 방법을 찾아 결합도를 낮춰야 한다
    - 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다
    - 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.
- 취약한 기반 클래스 문제
    - 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
    - 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어
    - 캡슐화를 약화시키고 결합도를 높인다
        - 부모 클래스의 구현의 변경이 자식 클래스의 변경으로 이어질 수 있다
- 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해라!
    - 하지만 문서화 -> 내부 구현의 노출 -> 캡슐화 위반
- 결합도란 다른 대상에 대해 알고 있는 지식의 양
- 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 자세히 알것을 강요
- 서브 클래스는 올바른 기능을 위해 슈퍼클래스의 세부적인 구현에 의존
- 취약한 기반 클래스의 문제를 조금이나마 완화시키기 위해서 필요한것은 `추상화`
    - 부모 클래스와 자식클래스 모두 추상화에 의존하도록 수정
- 코드 중복을 제거하기 위해 상속을 도입할 때 저자의 두가지원칙
    - 두 메서드가 유사하게 보이면 차이점을 메서드로 추출.
    - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로.
- 클래스 사이의 상속은 자식 클래스가 부모 클래스의 구현뿐만 아니라 인스턴스 변수에 대해서도 강하게 결합
    - 책임을 아무리 잘 분리 하더라도 인스턴스 변수의 추가는 조종 상속 계층 전반에 걸친 변경을 유발
    - 코드의 중복 vs 인스턴스 초기화 로직(생성자) 변경 -> 트레이드 오프
    - 객체 생성 로직에 대한 변경을 막기보다는 `핵심 로직의 중복을 막아라`
- 상속이 코드 재사용이라는 측면에서는 매우 강력한 도구이지만 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다

---

## 정리
- `중복된 코드`는 `변경`을 힘들게 만든다
- `코드 재사용`의 강력한 도구인 `상속`
- 하지만 강력한 도구인 만큼 여러 단점이 존재
- 자식 클래스가 부모 클래스의 구현, 인스턴스 변수 등에 강하게 결합 , 자식 클래스가 부모 클래스의 상세 내부 구현을 알아야함
-> `취약한 기반 클래스 문제 (높은 결합도, 캡슐화 위반)`
- `추상화`를 잘 활용하여 취약한 기반 클래스 문제를 완화하라
- 즉, `코드의 재사용 vs 강결합, 캡슐화 위반`의 장단점을 잘 고려하여 설계하자