- 어떤 프로그램이든 가장 기본적인 단위가 함수다.

## 작게 만들어라
- 함수를 만드는 첫째 규칙은 작게
### 블록과 들여쓰기
- 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

## 한가지만 해라
- 함수는 한가지를 해야한다. 그 한가지를 잘 해야한다. 그 한가지만을 해야한다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.
> 추상화의 수준... 애매한 느낌이다. 어느단계까지 추상화해야될까?

## 함수 당 추상화 수준은 하나로!
- 함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 한 함수내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
### 위에서 아래로 코드 읽기: 내려가기 규칙
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
- 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한단계씩 낮아진다.
- `핵심은 짧으면서 한가지만 하는 함수`

## Switch 문
- 본질적으로 Switch문은 N가지를 수행
- 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법
    - 다형성을 이용
    - [예제 실습](https://github.com/fDevJc/my-study/commit/d407f4a941b35367e96a6c899fe6b702131f4870)
- 물론 불가피하게 여러번 사용할 수 있는 경우가 있다

## 서술적인 이름을 사용하라
- 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다
- 이름이 길어도 좋다, 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 이름을 붙일 때는 일관성이 있어야 한다

## 함수 인수
- 함수에서 이상적인 인수 개수는 0개
- 다음은 1개, 2개. 3개 이상은 피하는 편이 좋다.
- 테스트 관점에서도 인수가 적으면 편하다
> 음 함수의 인수의 개수는 적은게 좋다고 동의하지만 매개변수 대신 인스턴스 변수를 선언하는 방법이 좋은 방법일까?
### 많이 쓰는 단항 형식
- 단항 형식의 흔한 경우는 두가지
    - 인수에 질문을 던지는 경우 (ex: boolean fileExists("FileName"))
    - 인수를 뭔가로 변환해 결과를 얻는 경우 (ex: InputStream fileOpen("FileName"))
    - 함수 이름을 지을 때는 두 경우를 분명히 구분해야한다.(`명령과 조회를 분리하라`)
    - 예외적으로 이벤트 함수도 존재
- 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.
- 입력 인수를 변환하는 함수라면 변환결과는 반환값으로 돌려준다.
### 플래그 인수
- boolean 값을 인수로 넘긴다는 것은 참이면 A를 하고 거짓이면 B를 하겠다는것. 즉 하나의 역할을 담당하지 않는다.
### 이항 함수
- 불가피한 경우도 있지만 가능하면 단항함수로 수정하려고 노력해야한다
### 삼항 함수
### 인수 객체
- 인수 2,3개가 필요할경우 클래스 변수로 선언하면 이름을 붙여야하므로 결국 개념을 표현
### 인수 목록
### 동사와 키워드

## 부수 효과를 일으키지 마라!
- 함수에서 한가지의 일을 약속하고 다른 일을 할경우 시간적인 결합, 순서 종속성을 초래
> 시간적 결합(Temporal Coupling), 순서종속성 : 소프트웨어의 설계 요소 자체로서의 시간 역할, 순서가 생기게 되면 프로그램의 유연성이 떨어지고 결합도가 높아진다. 의존이 없는 동시성을 보장하도록 프로그램을 개발해야한다.
```java
public class UserValidator{
    public boolean checkPassword(String username, String password){
        /*
            1.username 확인
            2.user가 존재하는 경우
            2-1. 패스워드확인
            2-2. 일치하면 세션 초기화
        */
    }
}
```
- 위의 로직에서 부수효과는 세션 초기화
- 메소드의 이름만봐서는 세션을 초기화하는 사실이 드러나지 않는다.
- 함수이름만 보고 함수를 호출할경우 세션을 초기화시킬 위험이 있다.
- 이런 부수효과가 시간적인 결합을 초래. 즉 세션을 초기화해도 괜찮은 경우에만 호출이 가능
- 만약 시간적 결합이 필요하다면 함수이름을 checkPasswordAndInitiallizeSession()이 적절
### 출력인수
- 일반적으로 인수를 함수 입력으로 해석
- 객체 지향언어에서는 출력 인수를 사용할 필요가 거의 없다
- 일반적으로 출력 인수는 피해야한다

## 명령과 조회를 분리하라
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
- 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나

## 오류 코드보다 예외를 사용하라
### Try/Catch 블록 뽑아내기
- 정상 동작과 오류 처리동작을 분리하면 코드를 이해하고 수정하기 쉬워진다
### 오류 처리도 한 가지 작업이다

## 반복하지 마라
- 소프트웨어 개발에서 지금까지 일어난 혁신은 소스 코드에서 중복을 제거하려는 지속적인 노력

## 구조적 프로그래밍
- 구조적 프로그래밍에서는 모든 함수의 입구 출구는 하나만 존재해야한다.
- 하지만 함수를 작게 만든다면 return, break, continue를 여러 차례 사용해도 괜찮다.

## 함수를 어떻게 짜죠?
- 단위테스트, 리팩토링 결국 TDD??

## 결론
- 프로그래밍 기술은 언제나 언어 설계의 기술
- 대가 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다.