# 05장_인덱스

- MySQL에서는 인덱싱이나 검색 방식에 따라 스토리지 엔진을 선택해야 할 수 도 있다.

## 5.1 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 IO를 줄이느냐가 큰 관건

### 5.1.1 저장 매체

- 내장 디스크
    - PC나 서버 내에 장착된 디스크와 같은 매체
    - 내부공간이 제한적이어 장착할 수 있는 디스크의 개수가 한정적
- DAS(Direct Attached Storage)
    - 컴퓨터의 본체와는 달리 디스크만 존재
    - 독자적으로 사용 X
    - SATA나 SAS와 같은 케이블로 연결
    - 성능은 내장 디스크와 유사
    - 반드시 하나의 컴퓨터 본체에만 연결가능하기때문에 여러대의 컴퓨터가 동시사용 불가능
- NAS(Network Attached Storage)
    - TCP/IP를 통해 연결
    - 동시에 여러 컴퓨터에서 공유해서 사용가능
    - 네트워크를 사용하여 SATA나 SAS의 직접연결에 비해 느림
    - 빈번한 데이터 읽고 쓰기가 필요한 데이터베이스 서버용으로는 거의 사용 X
- SAN(Storage Area Network)
    - DAS로 구축할 수 없는 대용량의 스토리지 공간을 제공
    - 여러 컴퓨터에서 동시에 사용가능
    - 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적
    - 비용이 많이듬

### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브

- CPU, 메모리등 주요장치는 전자식 장치
- 디스크 드라이브는 기계식 장치
- 데이터베이스 서버에서는 디스크 장치가 병목지점이 된다
- 기계식 디스크를 대체하기 위해 SSD(Solid State Drive)가 많이 출시되고있음
- SSD는 컴퓨터 메모리보다는 느리지만 기계식 디스크 드라이브보다는 훨씬 빠름
- 순차 IO에서는 기계식과 SSD의 차이가 크지 않지만 랜덤IO에서는 큰 차이를 보임

### 5.1.3 랜덤IO와 순차IO

- 랜덤IO라는 표현은 플래터(원판)을 돌려 읽어야할 데이터가 저장된 위치로 디스크 헤더를 옮긴다음 데이터를 읽는 것을 의미
- 디스크의 성능은 디스크헤더의 위치 이동없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정
- `일반적으로 쿼리를 튜닝하는 것은 랜덤 IO 자체를 줄여주는 것이 목적이라 할수 있다.`
- 인덱스 레인지 스캔은 랜덤 IO를 사용
- 풀 테이블 스캔은 순차 IO를 사용

## 5.2 인덱스란?

- 책의 찾아보기(색인)과 비유, 책의 내용은 데이터 파일
- 색인이 없다면 책의 내용을 다뒤져 필요한 정보를 찾을 것이다. 이렇듯 인덱스는 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 저장해두고 빠르게 정보를 찾을 수 있다.
- 또한 인덱스나 색인이 정렬이되어있지 않다면 색인을 다 뒤져 원하는 내용을 찾듯이 인덱스의 경우에도 미리 정렬하여 보관한다.
- 인덱스는 SortedList와 같은 자료구조이며, 데이터 파일은 ArrayList와 같은 자료구조이다.
- 인덱스는 데이터가 저장될때 항상 정렬을 해야하므로 저장하는 과정이 복잡하고 느리다. 하지만 검색의 경우 이미 정렬되어있기때문에 빠르게 찾을 수 있다.
- `DBMS에서 인덱스는 데이터의 저장,수정,삭제 성능을 희생하고 읽기 속도를 높이는 기능이다`
- `저장 속도를 어디까지 희생할 수 있는지, 읽기 속도는 얼마나 빠르게 만들어야되는지 조절을 해야한다.`
- 데이터 저장 방식 알고리즘으로는 B-Tree인덱스와 Hash 인덱스, Fractal-Tree인덱스 등이 있다.

### 5.3 B-Tree 인덱스

### 5.3.1 구조 및 특성

- 트리구조의 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 가장 하위의 노드는 리프노드라고 불리며 중간에 존재하는 노드는 브랜치 노드
- 인덱스의 키값은 정렬되어 저장되어있지만 데이터파일은 임의의순서로 저장

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있다.
- B-Tree에 저장 될 때는 키 값을 이용해 B-Tree상의 적절한 위치를 검색하고 B-Tree의 리프 노드에 저장한다. 이때 리프노드가 가득 차서 더는 저장할 수 없을 경우 리프노드가 분리돼야 하고 이는 상위 브랜치 노드까지 처리 범위가 넓어지게 된다.
- 이러한 이유로 쓰기작업에 비용이 많이 드는 것으로 알려짐
- MyISAM, Memory 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키값을 B-Tree 인덱스에 반영
- MyISAM 스토리지 엔진은 “deleay-key-write” 파라미터를 설정해 인덱스 추가 작업을 지연시킬 수 있다
- InnoDB 스토리지 엔진은 이 작업을 조금더 지능적으로 처리
    1. 사용자의 쿼리 실행
    2. InnoDB 버퍼풀에 인덱스키가 저장될 리프노드가 존재한다면 즉시 추가 작업
    3. 없다면 인서트버퍼에 임시기록해두고 작업완료(사용자쿼리 실행완료)
    4. 백그라운드 작업으로 인서트버퍼에 머지해야할 인덱스값 확인후 병합
    5. 서버 자원의 여유가 생기면 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스와 주소값을 머지(B-Tree 인덱스 키와 주소를 저장) 시킴
- 5.5이상 버전에서는 INSERT뿐만아니라 DELETE등의 인덱스 작업까지 지연 처리 가능

**인덱스 키 삭제**

- 해당 키값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크
- 마킹된 인덱스 키 공간은 방치되거나 재활용 가능

**인덱스 키 변경**

- 키값 삭제 후 다시 새로운 키값을 추가하는 형태

**인덱스 키 검색**

- `INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다`
- 인덱스의 키값에 변형이 가해진 후 비교되는 경우 인덱스 사용불가

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라하며 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 인덱스도 페이지단위로 관리되며, 루트,브랜치,리프 노드를 구분하는 기준이 페이지 단위이다.
- DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조이다.
- B-Tree의 자식노드는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. InnoDB의 모든 페이지 크기는 16KB로 고정돼 있다
- 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야 하는 횟수(페이지의 개수에따라)가 늘어나고, 그만큼 느려진다.
- 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것이고 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해 둘 수 있는 레코드 수는 줄어드는 것을 의미

**B-Tree 깊이**

- 직접적으로 제어할 방법은 없다.
- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤IO를 하는지와 직결되는 문제
- 인덱스 키값이 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아지고, 그때문에 같은 레코드 건수라 하더라도 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.

**선택도(Selectivity) 기수성(Cardinality)**

- 전체 인덱스 키값은 100개, 유니크한 값의 수는 10개라면 기수성은 10
- 중복된 값이 많아지면 기수성은 낮아지게되고, 선택도 또한 떨어진다.
- 인덱스는 선택도나 기수성이 높을 수록 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그룹핑 작업을 위해 인덱스를 만드는것이 좋은 선택일 수 있다. 인덱스가 항상 검색에만 사용되는 것이 아니기에 용도에 맞추어 적절히 인덱스를 설계해야 한다.
- `인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다`
    
    ```java
    전체 로우 수 10000건
    인덱스 country
    SELECT * FROM test WHERE country='KOREA' and city='SEOUL';
    
    country 컬럼의 유니크 값이 10건일경우
    - 1000건의 데이터중 city 값을 비교
    country 컬럼의 유니크 값이 1000건일경우
    - 10건의 데이터중 city 값을 비교
    ```
    

**읽어야 하는 레코드의 건수**

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것ㄱ보다 높은 비용이 드는 작업
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통한 레코드 1건을 읽는 것이 테이블 직접 레코드 1건을 읽는 것보다 약 4~5배 정도 비용이 더 드는 작업으로 예측

### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔**

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
- 인덱스의 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이때 리프노드에 저장된 레코드 주소로 데이터파일을 읽어오는데 레코드 한건 단위로 랜덤 IO가 발생한다. 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%가 넘으면 인덱스보다는 데이터를 직접읽는 것이 좋다.

**인덱스 풀 스캔**

- 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 풀 스캔은 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라 한다.
- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식 사용
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스를 읽는 것이 효율적
- 쿼리가 인덱스에 명시된 칼럼만으로 처리할 수 있는 경우 이 방식이 사용
- 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리X

**루스 인덱스 스캔**

- 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX()또는 MIN 함수등에 최적화하는 경우 사용

### 5.3.5 다중 칼럼(Multi-column) 인덱스

- 두 개 이상의 칼럼으로 구성된 인덱스
- `인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬`
- `다중 칼럼 인덱스에서 인덱스의 위치(순서)가 상당히 중요`

### 5.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스 키값은 항상 오름차순으로만 정렬되지만 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로 사용 가능

**인덱스의 정렬**

- 상용 DBMS에서는 인덱스 구성시 오름,내림차순 설정가능
- MySQL에서는 아직 지원안됨 ← 찾아보자🤔

**인덱스 스캔 방향**

```java
SELECT *
FROM emp ORDER BY first_name DSEC LIMIT 1;
```

- 인덱스의 경우 항상 오름차순으로 정렬돼 있지만 인덱스를 최소값부터 읽으면 오름차순으로 가져올 수 있고 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 알고있다.
- 쿼리의 ORDER BY 처리나 MIN, MAX함수 등의 최적화가 필요한 경우, MySQL 옵티마이저는 읽기 방향을 전환해서 사용하도록 실행 계획을 만든다.

### 5.3.7 B-Tree 인덱스의 가용성과 효율성

**비교 조건의 종류와 효율성**

```java
SELECT * FROM dept_emp
WHERE dept_no = 'd' AND emp_no >= 10114;

다중인덱스 케이스 A : dept_no + emp_no
다중인덱스 케이스 B : emp_no + dept_no
```

- 케이스 A의 경우 부서로 정렬된 뒤 사번으로 정렬되어있기 때문에 해당 조건에 맞는 첫 레코드를 찾은뒤 해당부서가 아닐때까지 쭉 읽기만 하면된다.
- 케이스 B의 경우 사번으로 정렬된 뒤 부서로 정렬되어있기 때문에  해당 조건에 맞는 레코드를 찾은 뒤 모든 레코드에 대해 부서를 확인해야 한다. 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 ‘필터링'이라 한다.
- `즉 동일하게 2개의 칼럼을 인덱스로 지정하였지만 순서에 따라 읽고 비교하는 과정이 차이가 나게 된다. 인덱스의 순서를 잘 생각하여 설계하여야 한다.`

**인덱스의 가용성**

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬

```java
SELECT * FROM emp WHERE first_name LIKE '%a';
```

- 위의 쿼리는 인덱스 레인지 스캔 방식으로 인덱스 사용 불가능
- 왼쪽부터 비교하여 일치하는 레코드를 찾아야하는데 왼쪽부분이 고정되지 않았기 떄문

```java
SELECT * FROM dept_emp WHERE emp_no >= 10000;

인덱스 : dept_no + emp_no
```

- dept_no 값없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용 불가
- 부서로 정렬된뒤 사번으로 정렬되었기때문

**가용성과 효율성 판단**

- B-Tree 인덱스의 특성상 다음 조건에서는 사용 할 수 없다. (작업범위결정조건으로, 체크조건으로는 가능)
    - NOT-EQUAL로 비교된 경우
    - LIKE ‘%??’
    - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용되는 경우
    - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
    - 문자열 데이터 타입의 콜레이션이 다른 경우

## 해시(Hash) 인덱스

- 해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다.
- 일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현
- 테이블의 인덱스뿐 아니라 InnoDB의 버퍼 풀에서 빠른 검색을 위한 어댑티브 해시 인덱스로 사용되기도하고, 오라클에서는 조인에 사용되기도 한다.

### 5.4.1 구조 및 특성

- 해시 인덱스의 큰 장점은 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠름
- 해시 인덱스는 트리 형태의 구조가 아니고 검색하고자 하는 값을 주면 해시 함수를 통해 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있다.
- B-Tree 인덱스나 해시 인덱스 모두 각 키값과 레코드 주소값 등의 정보를 저장해 두는 공간이 필요 B-Tree에서는 고정된 크기의 작업 기본단위 공간을 노드라고하며, 해시 인덱스에서는 버켓이라고한다.
- 해시 인덱스에 저장되는 키값은 4~8바이트 수준, B-Tree인덱스보다 상당히 크기가 작은 편
- `해시 함수의 결과 값의 범위가 넓으면 그만큼 버켓이 많이 필요해서 공간의 낭비, 값의 범위가 작으면 충돌이 많아져 인덱스의 장점이 사라진다.`

### 5.4.2 해시 인덱스의 가용성 및 효율성

- 해시 인덱스는 빠른 검색을 제공하지만 키값자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬할 수 없다.
- 작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리
    - =, <=>, IN, IS NULL, IS NOT NULL
- 해시 인덱스를 전혀 사용하지 못하는 쿼리
    - ≥, BETWEEN, LIKE, <>

## R-Tree 인덱스

- (P236)

### 5.5.1 구조 및 특성

### 5.5.2 R-Tree 인덱스의 용도

## 5.6 Fractal-Tree 인덱스

- (P241)

### 5.6.1 Fractal-Tree의 특성

### 5.6.2 Fractal-Tree의 가용성과 효율성

## 5.7 전문 검색(Full Text search) 인덱스

- (P244)

### 5.7.1 인덱스 알고리즘

**구분자(Stopword) 기법**

**N-그램(n-Gram) 기법**

### 5.7.2 구분자와 N-그램의 차이

### 5.7.3 전문 검색 인덱스의 가용성

## 5.8 비트맵 인덱스와 함수 기반 인덱스

- (P250)

## 5.9 클러스터링 인덱스

- 클러스터란 여러 개를 하나로 묶는다는 의미로 주로 사용
- 인덱스에서 클러스터링은 비슷한 것들을 묶어서 저장하는 형태로 구현
- MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원

### 5.9.1 클러스터링 인덱스

- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
- `프라이머리 키값에 의해 레코드의 저장 위치가 결정`
- 프라이머리 키값이 변경된다면 물리적인 저장 위치가 바뀌어야 한다는 것을 의미
- 클러스터링 인덱스는 프라이머리 키값에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수도 있음
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리

### 5.9.2 보조 인덱스(Secondary index)에 미치는 영향

- MyISAM이나 MEMORY 테이블과 같은 클러스터링되지 않은 테이블은 INSERT될 때 한번 저장된 공간에서 절대 이동하지 않는다.

### 5.9.3 클러스터 인덱스의 장점과 단점

- 장점
    - 프라이머리키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우 많음. 이를 커버링 인덱스라고 함
- 단점
    - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키값의 크기가 클 경우 인덱스 크기가 커짐
    - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느림
    - INSERT할때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할때 DELTE, INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

### 5.9.4 클러스터 테이블 사용 시 주의사항

- InnoDB(클러스터 테이블) 에서는 주의 사항이 있음
    - 클러스터 인덱스 키의 크기
    - 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성할 것(가능한 경우)
    - 프라이머리 키는 반드시 명시할 것
    - AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

## 5.10 유니크 인덱스

- 유니크란 사실 인덱스라기보다는 제약 조건에 가까움
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음

### 5.10.1 유니크 인덱스와 일반 보조 인덱스의 비교

- 인덱스 읽기
    - 1개의 레코드를 읽느냐 2개 이상의 레코드를 읽느냐의 차이
    - 읽어야할 레코드의 건수가 같다면 유니크 인덱스와 일반 보조 인덱스는 성능상 차이 미비
- 인덱스 쓰기
    - 유니크 인덱스의 키값을 쓸때는 중복이 있는지 판단하는 체크과정이 한단계 더 필요
    - 일반 보조 인덱스의 쓰기보다 느림
    - MySQL에서는 유니크 인덱스에 중복값을 체크할때는 읽기 잠금, 쓰기를 할때는 쓰기 잠금을 사용하는데 이과정에서 데드락이 빈번하게 발생
    - InnoDB 스토리지 엔진에서는 인덱스 키의 저장을 버퍼링하기 위해 인서트 버퍼가 사용된다 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링 하지 못한다.
    

### 5.10.2 유니크 인덱스 사용 시 주의사항

- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.
- 똑같은 칼럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 설정한경우도 불필요한 중복이다.
- 결론적으로 유일성이 꼭 보장되어야하는 칼럼에 대해서는 유니크 인덱스를 사용하지만, 그렇지 않은 경우 유니크 인덱스보다는 보조 인덱스를 사용하는 것이 권장된다.

## 5.11 외래키

- MySQL에서 외래키는 InnoDB 엔진에서만 생성가능
- 특징
    - 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생
    - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금경합을 발생시키지 않는다.

### 5.11.1 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것
- 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

### 5.11.2 부모 테이블의 변경 작업이 대기하는 경우

- 자식테이블의 업데이트 이후 커밋 롤백전 부모 테이블의 레코드를 삭제하는 경우 부모테이블 삭제 커넥션의 경우 기다림
- 이는 자식 테이블이 생성될 때 정의된 외래키의 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되도록 작동하기 때문
- 데이터베이스에서 외래 키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 개발을 진행하는 것이 좋음.

## 5.12 기타 주의사항

- **스토리지 엔진별 지원 인덱스 목록**
    - MyISAM
        - B-Tree, R-Tree, Fulltext-index
    - InnoDB
        - B-Tree
    - Memory
        - B-Tree, Hash
    - TokuDB
        - Fractal-Tree
    - NDB(MySQL Cluster)
        - Hash, B-Tree
- InnoDB와 MyISAM 모두 거의 칼럼의 Cardinality에 의존해 실행계획을 세움
- 통계정보가 상당히 자주 업데이트됨, 쿼리의 실행계획이 의도한것과 다르게 만들어질 수 있다.
