- 대칭키 Symmetric Encryption
    - using the same key
- 비대칭키 Asymmetric Encryption
    - private and public key
    - using java keytool
- {cipher}
- RSA 암호화
- keytool 명령어
    - keytool -genkeypair -alias apiEncryptionKey -keyalg RSA -dname "CN= Yang, OU=API Development, O=fdevjc@gmail.com, L=Seoul, C=KR" -keypass "keypass" -keystore apiEncryptiongKey.jks -storepass "storepass"
    - keytool -list -keystore apiEncryptiongKey.jks -v
    - keytool -export -alias apiEncryptionKey -keystore apiEncryptionKey.jks -rfc -file trustServer.cer
- @LoadBalanced
    - RestTemplate 빈 설정에 붙여주면 서비스네임으로 찾아갈수있음
- 마이크로 서비스간 통신 - RestTemplate , OpenFeign
- RestTemplate
    - restTemplate.exchange
- Feign
    - @FeignClient(name = "order-service")를 포함한 인터페이스 작성
    - Feign 에러처리 - 인터페이스 ErrorDecoder 구현
- 복수의 동일한 마이크로서비스를 운영할때
    - 데이터의 분산 저장 → 동기화 문제
        - 해결방법
            - 하나의 데이터베이스 사용
            - 데이터베이스간의 동기화(메시지 큐잉 서버)
            - 메시지 큐잉서버 + 하나의 디비
- Apache kafka
    - Apache Software Foundation의 Scalar 언어로 된 오픈 소스 메시지 브로커 프로젝트
        - Open Source Message Broker Project
    - 실시간 데이터 피드를 관리하기 위해 통일된 높은 처리량 낮은 지연 시간을 지닌 플랫폼 제공
    - 나타난 배경
        - End-to-End 연결 방식의 아키텍처
        - 데이터 연동의 복잡성 증가 (HW, 운영체제, 장애 등)
        - 서로 다른 데이터 Pipeline 연결 구조
        - 확장이 어려운 구조
        - 그래서 모든 시스템으로 데이터를 실시간으로 전송하여 처할 수 있는 시스템, 
        데이터가 많아지더라도 확장이 용이한 시스템이 필요로 했다.
    - 카프카를 사용하게 되면 메시지를 보내는 입장, 받는 입장에서는 누구한테 메시지를 보내는지 누구로 부터 메시지를 받는지 알필요없이 카프카만 바라보면 된다.
    - Producer/Consumer를 분리
    - 메시지를 여러 Consumer에게 허용
    - 높은 처리량을 위한 메시지 최적화
    - scale-out 가능
    - Eco-system
    - kafka broker
        - 실행 된 kafka 애플리케이션 서버
        - 3대 이상의 broker cluster 구성
        - zookeeper 연동
            - 역할: 메타데이터 (브로커ID, 컨트롤러 ID 등) 저장
            - Controller 정보 저장
        - n개 Broker 중 1대는 Controller 기능 수행
            - Controller 역할
                - 각 Broker에게 담당 파티션 할당 수행
                - Broker 정상 동작 모니터링 관리
