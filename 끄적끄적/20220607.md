- 빈 후처리기
- @PostConstruct
    - 초기화 메소드에 부여해주면 스프링은 빈의 오브젝트를 생성하고 DI를 마친 뒤에 
    @PostConstruct가 붙은 메소드를 자동으로 실행
- 디폴트 의존관계
    - 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계
- Resource , ResourceLoader
- 오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있고, 이를 객체 지향 설계 원칙에서는 인터페이스 분리원칙(Interface Segregation Principle)이라 한다
- 인터페이스를 확장하고 싶을때, 이미 인터페이스를 이용하는 클라이언트가 존재할 때 인터페이스 자체를 수정하는 건 바람직한 방법이 아니다.
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공한다는 인터페이스 분리 원칙을 지키기 위해서라도 이미 적용한 인터페이스를 건드리면 안된다.
- 대신 새롭게 추가할 기능을 사용하는 클라이언트를 위해 새로운 인터페이스를 정의하거나 기존 인터페이스를 확장하는 게 바람직하다.
- 기존의 인터페이스를 상속하고 메소드를 추가해서 새로운 인터페이스로 정의해야 된다.
- 인터페이스를 추가하거나 상속을 통해 확장하는 방식을 잘 활용하면 이미 기존의 인터페이스를 사용하는 클라이언트가 있는 경우에도 유연한 확장이 가능하다
- 중요한건 클라이언트가 정말 필요한 기능을 가진 인터페이스를 통해 오브젝트에 접근하도록 만들었는가 이다.
- 잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려 있다. 인터페이스를 적절하게 분리하고 확장하는 방법을 통해 오브젝트 사이의 의존관계를 명확하게 해주고, 기존 의존관계에 영향을 주지 않으면서 유연한 확장성을 얻는 방법이 무엇인지 항상 고민해야 한다.
- ConcurrentHashMap 동기화된 해시 데이터 조작에 최적화되도록 만들어짐
데이터 조작시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다.
- 두개의 테스트가 중복되는 코드가 많을 경우 추상 테스트 클래스를 만들고 상속받는 방법도 있다.
- 애노테이션
    - 애노테이션은 기존의 자바 프로그래밍 방식으로는 활용할 수 없다. 애노테이션은 옵션에 따라 컴파일된 클래스에 존재하거나 애플리케이션이 동작할 때 메모리에 로딩되기도 하지만 자바 코드가 실행되는 데 직접 참여하지 못한다. 인터페이스처럼 오브젝트에 타입을 부여하는 것도 아니고, 그 자체로 상속이나 오버라이딩이 가능하지도 않다. 동작하는 코드를 넣을 수 없는것은 물론이고, 코드에서 간단히 참조하거나 활용할 수가 없다. 복잡한 리플렉션 API를 이용해 애노테이션의 메타정보를 조회하고, 애노테이션 내에 설정 된값을 가져와 참고하는 방법이 전부다.
    - 그런데 애노테이션의 활용이 늘어난 이유는 무엇일까?
    애노테이션은 애플리케이션을 핵심 로직을 담은 자바코드와 이를 지원하는 IoC 방식의 프레임워크, 그리고 프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘어울리기 때문이다. 애노테이션은 프레임워크가 참조하는 메타정보로 사용되기에 여러가지 유리한점이 많다.
- @PropertySource
- PropertySourcesPlaceholderConfigurer
- @Value
