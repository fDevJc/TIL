# 05장_인덱스

- MySQL에서는 인덱싱이나 검색 방식에 따라 스토리지 엔진을 선택해야 할 수 도 있다.

## 5.1 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 IO를 줄이느냐가 큰 관건

### 5.1.1 저장 매체

- 내장 디스크
    - PC나 서버 내에 장착된 디스크와 같은 매체
    - 내부공간이 제한적이어 장착할 수 있는 디스크의 개수가 한정적
- DAS(Direct Attached Storage)
    - 컴퓨터의 본체와는 달리 디스크만 존재
    - 독자적으로 사용 X
    - SATA나 SAS와 같은 케이블로 연결
    - 성능은 내장 디스크와 유사
    - 반드시 하나의 컴퓨터 본체에만 연결가능하기때문에 여러대의 컴퓨터가 동시사용 불가능
- NAS(Network Attached Storage)
    - TCP/IP를 통해 연결
    - 동시에 여러 컴퓨터에서 공유해서 사용가능
    - 네트워크를 사용하여 SATA나 SAS의 직접연결에 비해 느림
    - 빈번한 데이터 읽고 쓰기가 필요한 데이터베이스 서버용으로는 거의 사용 X
- SAN(Storage Area Network)
    - DAS로 구축할 수 없는 대용량의 스토리지 공간을 제공
    - 여러 컴퓨터에서 동시에 사용가능
    - 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적
    - 비용이 많이듬

### 5.1.2 디스크 드라이브와 솔리드 스테이트 드라이브

- CPU, 메모리등 주요장치는 전자식 장치
- 디스크 드라이브는 기계식 장치
- 데이터베이스 서버에서는 디스크 장치가 병목지점이 된다
- 기계식 디스크를 대체하기 위해 SSD(Solid State Drive)가 많이 출시되고있음
- SSD는 컴퓨터 메모리보다는 느리지만 기계식 디스크 드라이브보다는 훨씬 빠름
- 순차 IO에서는 기계식과 SSD의 차이가 크지 않지만 랜덤IO에서는 큰 차이를 보임

### 5.1.3 랜덤IO와 순차IO

- 랜덤IO라는 표현은 플래터(원판)을 돌려 읽어야할 데이터가 저장된 위치로 디스크 헤더를 옮긴다음 데이터를 읽는 것을 의미
- 디스크의 성능은 디스크헤더의 위치 이동없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 IO 자체를 줄여주는 것이 목적이라 할수 있다.
- 인덱스 레인지 스캔은 랜덤 IO를 사용
- 풀 테이블 스캔은 순차 IO를 사용

## 5.2 인덱스란?

- 책의 찾아보기(색인)과 비유, 책의 내용은 데이터 파일
- 색인이 없다면 책의 내용을 다뒤져 필요한 정보를 찾을 것이다. 이렇듯 인덱스는 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 저장해두고 빠르게 정보를 찾을 수 있다.
- 또한 인덱스나 색인이 정렬이되어있지 않다면 색인을 다 뒤져 원하는 내용을 찾듯이 인덱스의 경우에도 미리 정렬하여 보관한다.
- 인덱스는 SortedList와 같은 자료구조이며, 데이터 파일은 ArrayList와 같은 자료구조이다.
- 인덱스는 데이터가 저장될때 항상 정렬을 해야하므로 저장하는 과정이 복잡하고 느리다. 하지만 검색의 경우 이미 정렬되어있기때문에 빠르게 찾을 수 있다.
- DBMS에서 인덱스는 데이터의 저장,수정,삭제 성능을 희생하고 읽기 속도를 높이는 기능이다
- 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도는 얼마나 빠르게 만들어야되는지 조절을 해야한다.
- 데이터 저장 방식 알고리즘으로는 B-Tree인덱스와 Hash 인덱스, Fractal-Tree인덱스 등이 있다.

### 5.3 B-Tree 인덱스

### 5.3.1 구조 및 특성

- 트리구조의 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 가장 하위의 노드는 리프노드라고 불리며 중간에 존재하는 노드는 브랜치 노드
- 인덱스의 키값은 정렬되어 저장되어있지만 데이터파일은 임의의순서로 저장

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있다.
- B-Tree에 저장 될 때는 키 값을 이용해 B-Tree상의 적절한 위치를 검색하고 B-Tree의 리프 노드에 저장한다. 이때 리프노드가 가득 차서 더는 저장할 수 없을 경우 리프노드가 분리돼야 하고 이는 상위 브랜치 노드까지 처리 범위가 넓어지게 된다.
- 이러한 이유로 쓰기작업에 비용이 많이 드는 것으로 알려짐
- MyISAM, Memory 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키값을 B-Tree 인덱스에 반영
- MyISAM 스토리지 엔진은 “deleay-key-write” 파라미터를 설정해 인덱스 추가 작업을 지연시킬 수 있다
- InnoDB 스토리지 엔진은 이 작업을 조금더 지능적으로 처리
    1. 사용자의 쿼리 실행
    2. InnoDB 버퍼풀에 인덱스키가 저장될 리프노드가 존재한다면 즉시 추가 작업
    3. 없다면 인서트버퍼에 임시기록해두고 작업완료(사용자쿼리 실행완료)
    4. 백그라운드 작업으로 인서트버퍼에 머지해야할 인덱스값 확인후 병합
    5. 서버 자원의 여유가 생기면 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스와 주소값을 머지(B-Tree 인덱스 키와 주소를 저장) 시킴
- 5.5이상 버전에서는 INSERT뿐만아니라 DELETE등의 인덱스 작업까지 지연 처리 가능

**인덱스 키 삭제**

- 해당 키값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크
- 마킹된 인덱스 키 공간은 방치되거나 재활용 가능

**인덱스 키 변경**

- 키값 삭제 후 다시 새로운 키값을 추가하는 형태

**인덱스 키 검색**

- INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다
- 인덱스의 키값에 변형이 가해진 후 비교되는 경우 인덱스 사용불가

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라하며 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 인덱스도 페이지단위로 관리되며, 루트,브랜치,리프 노드를 구분하는 기준이 페이지 단위이다.
- DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조이다.
- B-Tree의 자식노드는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. InnoDB의 모든 페이지 크기는 16KB로 고정돼 있다
- 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야 하는 횟수(페이지의 개수에따라)가 늘어나고, 그만큼 느려진다.
- 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것이고 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해 둘 수 있는 레코드 수는 줄어드는 것을 의미

**B-Tree 깊이**

- 직접적으로 제어할 방법은 없다.
- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤IO를 하는지와 직결되는 문제
- 인덱스 키값이 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아지고, 그때문에 같은 레코드 건수라 하더라도 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.

**선택도(Selectivity) 기수성(Cardinality)**

- 전체 인덱스 키값은 100개, 유니크한 값의 수는 10개라면 기수성은 10
- 중복된 값이 많아지면 기수성은 낮아지게되고, 선택도 또한 떨어진다.
- 인덱스는 선택도나 기수성이 높을 수록 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그룹핑 작업을 위해 인덱스를 만드는것이 좋은 선택일 수 있다. 인덱스가 항상 검색에만 사용되는 것이 아니기에 용도에 맞추어 적절히 인덱스를 설계해야 한다.
- 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다
    
    ```java
    전체 로우 수 10000건
    인덱스 country
    SELECT * FROM test WHERE country='KOREA' and city='SEOUL';
    
    country 컬럼의 유니크 값이 10건일경우
    - 1000건의 데이터중 city 값을 비교
    country 컬럼의 유니크 값이 1000건일경우
    - 10건의 데이터중 city 값을 비교
    ```
    

**읽어야 하는 레코드의 건수**

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것ㄱ보다 높은 비용이 드는 작업
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통한 레코드 1건을 읽는 것이 테이블 직접 레코드 1건을 읽는 것보다 약 4~5배 정도 비용이 더 드는 작업으로 예측

### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔**

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
- 인덱스의 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이때 리프노드에 저장된 레코드 주소로 데이터파일을 읽어오는데 레코드 한건 단위로 랜덤 IO가 발생한다. 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%가 넘으면 인덱스보다는 데이터를 직접읽는 것이 좋다.

**인덱스 풀 스캔**
